## 定义
> 最近公共祖先 简称 LCA（Lowest Common Ancestor）。

两个节点的最近公共祖先，就是这两个点深度最深的公共祖先。
规定：自己也是自己的祖先

## 算法

### 一、朴素算法


首先计算出节点 $a$,$b$ 的深度 $d_1, d_2$。如果 $d_1 < d_2$，即 $b$ 比 $a$ 深，将节点 $b$ 向上移动 $d_2-d_1$ 步，此时 $a$,$b$ 在同一个深度。下面只需要将 $a$,$b$ 同时向上移动，直到他们相遇，相遇的节点即 $a$,$b$ 的最近公共祖先。

该算法时间复杂度为 $O(nm)$，对多次询问的题目无法解决

### 二、倍增算法

#### 思路
倍增算法本质上是对朴素算法的优化。通过数组 $P_{u,i}$ 记录节点 $u$ 向上移动 $2^i$ 步到达的节点。

$p$ 数组的预处理：
```p[u][0] = fa[u]```， ```p[u][i] = p[p[u][i-1]][i-1]```
#### 代码

**$p$ 数组的预处理：**
```C++
void dfs(int u, int fa) {
    d[u] = d[fa] + 1; // 同时计算深度
    p[u][0] = fa;
    for (int i = 1; (1 << i) <= d[u]; ++i) { // 防止跳出根节点
        p[u][i] = p[p[u][i-1]][i-1];
    }
    for (int v: e[u]) 
        if (v != fa) dfs(v, u);
}
```

**使 $a$,$b$ 到达同一深度：**
```C++
if (d[a] > d[b]) swap(a, b);
for (int i = num; i >= 0; --i) // 2^num 恰小于最大深度
    if (d[a] <= d[b] - (1 << i)) 
        b = p[b][i];
```
注：若此时 $a=b$，则最近公共祖先就是 $a$，输出 $a$ 并```continue```

**$a$,$b$ 一起向上移动：**
```C++
for (int j = 20; j >= 0; --j) 
    if (p[a][j] != p[b][j]) 
        a = p[a][j], b = p[b][j]; 
```

则最后的答案为 ```p[a][0]```;

### 三、LCA 中的 Tarjan 算法

#### 思路
Tarjan 算法是一种离线算法，即在一次遍历中把所有询问都解决，时间复杂度 O(n+q)

该算法需用到并查集，以下为该算法的操作流程

